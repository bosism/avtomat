<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVTOMAT - –í–µ–±-–≤–µ—Ä—Å–∏—è</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #282c34; /* Dark background */
            color: #abb2bf; /* Light grey text */
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            background-color: #353a43; /* Slightly lighter dark for container */
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 700px;
            width: 90%;
        }

        header h1 {
            color: #61afef; /* Blue accent */
            font-family: "Courier New", Courier, monospace; /* Monospaced for title */
        }

        #ascii-art-rifle {
            font-family: "Consolas", "Courier New", Courier, monospace;
            letter-spacing: 0;
            white-space: pre;
            background-color: #21252b; /* Darker background for pre */
            color: #98c379; /* Green accent for "code" */
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            text-align: left;
            border: 1px solid #4b5263;
            margin-bottom: 20px; /* Added margin */
            line-height: 1.2; /* Adjust line height for better art display */
        }

        .controls button {
            margin: 8px;
            padding: 12px 18px;
            border: none;
            border-radius: 5px;
            background-color: #61afef; /* Blue accent */
            color: #282c34; /* Dark text on button */
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out;
        }

        .controls button:hover {
            background-color: #5295cc; /* Darker blue on hover */
        }

        .output-area {
            margin-top: 25px;
            padding: 20px;
            background-color: #21252b; /* Darker background for output */
            border-radius: 5px;
            min-height: 60px;
            font-size: 1.3em;
            /* color: #e5c07b; */ /* Moved to #phraseOutputSpan */
            border: 1px solid #4b5263;
            word-wrap: break-word;
            text-align: left; /* For better editing experience */
            display: flex; /* To align text and icons nicely */
            align-items: center; /* Vertically align text and icons */
        }
        #phraseOutputSpan {
            flex-grow: 1; /* Allow text span to take available space */
            color: #e5c07b; /* Yellow/Orange accent for output text */
            outline: none; /* Remove default outline, we'll add a custom focus style */
        }
        .output-actions {
            flex-shrink: 0; /* Prevent icons from shrinking */
            margin-left: 10px; /* Space between text and icons */
        }

        .icon-button {
            background: none;
            border: none;
            color: #abb2bf; /* Light grey text, same as body */
            cursor: pointer;
            font-size: 1.2em; /* Adjust icon size */
            padding: 5px;
            margin-left: 5px; /* Space between icons */
            transition: color 0.2s ease-in-out;
        }

        .icon-button:hover {
            color: #61afef; /* Blue accent on hover */
        }

        #phraseOutputSpan[contenteditable="true"]:focus {
            outline: 1px solid #61afef !important; /* Blue accent for focus, !important to override browser defaults if any */
            background-color: #2c313a; /* Slightly lighter background when editing */
            box-shadow: 0 0 3px rgba(97, 175, 239, 0.3); /* Optional: add a glow */
        }

        footer {
            margin-top: 25px;
            font-size: 0.9em;
            color: #7f848e; /* Muted grey for footer */
        }
        /* Add this to the <style> block */
        .controls label {
            color: #abb2bf; /* Match text color */
            margin-right: 10px;
            font-weight: bold; /* Match button text weight */
        }

        .controls select {
            margin: 8px;
            padding: 10px 12px; /* Slightly less padding than buttons */
            border: 1px solid #4b5263; /* Match border color */
            border-radius: 5px;
            background-color: #353a43; /* Match container background */
            color: #abb2bf; /* Match text color */
            font-size: 1em;
            cursor: pointer;
            transition: border-color 0.2s ease-in-out, background-color 0.2s ease-in-out;
        }

        .controls select:hover {
            border-color: #61afef; /* Blue accent on hover */
        }

        .controls select:focus {
            outline: none;
            border-color: #61afef;
            box-shadow: 0 0 5px rgba(97, 175, 239, 0.5);
        }

        .controls select:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AVTOMAT</h1>
            <pre id="ascii-art-rifle">
                     ________________
                    //~~~~~~~~~~~~~~\\                  /‚îê
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ_____[=~~~~~~~~~~~~~~~~~~‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚îê   /__‚îÇ
‚îÇ~~                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ=======####
‚îÇ   ~~~_=====~~~~~‚îÄ‚î¨   ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îêo      ‚îå‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚îò      '
‚îÇ   _-~            ‚îÇ   ‚îÇ_____‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 ~~~               ‚îÇ   ‚îÇ     ‚îÇ||  |  ‚îÇ AvtoMat Profesional 1.0
                   ‚îÇ   ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îî‚îÄ‚îÄ‚îÄ‚î¥

            </pre>
        </header>

        <div class="controls">
            <label for="voiceSelect" id="voiceLabel">–ì–æ–ª–æ—Å:</label>
            <select id="voiceSelect"></select>
            <button id="generateButton">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å (–ª—é–±–∞—è –∫–ª–∞–≤–∏—à–∞)</button>
            <button id="toggleSpeechButton">–†–µ—á—å: –í–∫–ª</button>
            <!-- <button id="toggleSpeechSourceButton">–ò—Å—Ç–æ—á–Ω–∏–∫ —Ä–µ—á–∏: Raw</button> Removed -->
            <!-- <button id="saveButton">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ—Ä–∞–∑—É</button> Removed -->
        </div>

        <div class="output-area">
            <span id="phraseOutputSpan" contenteditable="true">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏–ª–∏ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É –¥–ª—è –Ω–∞—á–∞–ª–∞...</span>
            <span class="output-actions">
                <button id="repeatSpeechIconButton" class="icon-button" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Ä–µ—á—å">üîä</button> <!-- Speaker Icon -->
                <button id="copyToClipboardButton" class="icon-button" title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å">üìã</button> <!-- Clipboard Icon -->
            </span>
        </div>

        <footer>
            <p>–ù–∞–∂–º–∏—Ç–µ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. 'T' - –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ä–µ—á—å.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Data from Pascal program ---
            const MaxWords = 12;
            const MaxPrefixes = 11;
            const MaxDermo = 21;
            const MaxSuffixes = 2; // Per gender
            const MaxPronouns = 1; // Per gender
            const StackSize = 5;

            const words = ['—Ö—É–µ', '–ø–∏–∑–¥–æ', '–¥–µ—Ä—å–º–æ', '–∂–æ–ø–æ', '—á–ª–µ–Ω–æ', '–ø–∞—Ä–∞—à–µ', '–≥–∞–Ω–¥–æ–Ω–æ', '–º—É–¥–æ', '—Å—É–∫–æ', '–≤–∞—Ñ–ª–µ', '–∑–∞–ª—É–ø–æ', '–ø–æ–Ω–æ—Å–æ'];
            const prefixes = ['–∑–∞', '–≤—ã', '–ø—Ä–æ', '—Ä–∞–∑', '–Ω–∞–¥', '–ø–æ–¥', '–ø–µ—Ä–µ', '–Ω–µ–¥–æ', '–æ–±', '–≤', '–æ—Ç'];
            const dermo = ["–π–æ'–±—ã–≤", "–¥—Ä–∏'—Å—Ç—ã–≤", "—Å–∞'—Å—ã–≤", '—Å–µ—Ä', "–¥—Ä–∞'—á–∏–≤", "–∂—É'–∂–∂–∏–≤", '–µ–¥', '–∂–∏—Ä', "–≥–ª–∞'—Ç—ã–≤", '—Ä—ã–≤', "—Ö—É—è'—Ä–∏–≤", "–ª–∏'–∑—ã–≤", '–¥–µ—Ä', "–ª–∞'–º—ã–≤", '–±–∏–≤', '—Ä–µ–∑', "–ø–∏'–∑–∂–∏–≤", "—Ö–≤–∞'—Ç—ã–≤", "–∫—É'—Å—ã–≤", "–ø–∏–∑–¥—Ä—é'—á–∏–≤", '–∂–∏–º'];

            // JS arrays are 0-indexed, Pascal arrays were 1-indexed for suffixes/pronouns inner arrays
            // Gender: 0 (masc), 1 (fem), 2 (neuter)
            const suffixes = [
                ["–∞'–ª—å—â–∏–∫", "–∞'—Ç–µ–ª—å"],    // Gender 0
                ["–∞'–ª–∫–∞", "–∞'–ª—å—â–∏—Ü–∞"],  // Gender 1
                ["–∞'–ª–∏—â–µ", "–∞'–ª–æ"]       // Gender 2
            ];
            const pronouns = [
                ["–∞'—é—â–∏–π"],             // Gender 0
                ["–∞'—é—â—è—è"],             // Gender 1
                ["–∞'—é—â–µ–µ"]              // Gender 2
            ];

            // --- Global state ---
            let currentPhraseRaw = '';
            let currentPhraseReadable = '';
            let speechEnabled = true; // Speech is on by default
            let stack1 = []; // For words indices
            let stack2 = []; // For dermo indices

            // --- UI Elements ---
            const voiceSelect = document.getElementById('voiceSelect');
            const generateButton = document.getElementById('generateButton');
            const toggleSpeechButton = document.getElementById('toggleSpeechButton');
            // const toggleSpeechSourceButton = document.getElementById('toggleSpeechSourceButton'); // Removed
            const phraseOutputSpan = document.getElementById('phraseOutputSpan');
            const repeatSpeechIconButton = document.getElementById('repeatSpeechIconButton');
            const copyToClipboardButton = document.getElementById('copyToClipboardButton');

            let selectedVoice = null; // Variable to hold the selected voice object
            // --- Helper Functions ---
            function getRandomInt(max) { // Returns 0 to max-1
                return Math.floor(Math.random() * max);
            }

            function readable(s) {
                let str = '';
                for (let i = 0; i < s.length; i++) {
                    if (s[i] === '–π' && s[i + 1] === '–æ' && i < s.length - 1) {
                        str += '—ë'; // Cyrillic '—ë' (yo) - was '–µ' before, '—ë' is more accurate for "–π–æ"
                        i++;
                    } else if (s[i] !== "'") { // Changed from '+' to "'"
                        str += s[i];
                    }
                }
                return str;
            }

            function addToStack(stack, item) {
                if (stack.length >= StackSize) {
                    stack.shift(); // Remove oldest
                }
                stack.push(item);
            }

            function isInStack(stack, item) {
                return stack.includes(item);
            }

            function generateWordIndices() {
                let rw, rd;
                do {
                    rw = getRandomInt(MaxWords); // 0-indexed
                } while (isInStack(stack1, rw));
                addToStack(stack1, rw);

                do {
                    rd = getRandomInt(MaxDermo); // 0-indexed
                } while (isInStack(stack2, rd));
                addToStack(stack2, rd);
                return { rw, rd };
            }

            // --- Phrase Templates ---
            const phraseTemplates = [
                "{s1}\u00A0{s2}",                      // Original structure
                "{s1}\u00A0{s3}\u00A0{s2}",            // Original structure
                "{s2}",                               // Original structure
                "—Ö—É–π"/*,                                // Original profane option
                "–Ω—É\u00A0{s1}",
                "–±–ª—è–¥—å,\u00A0{s2}",
                "{s1},\u00A0–∞\u00A0–ø–æ—Ç–æ–º\u00A0{s2}",
                "–µ–±—É—á–∏–π\u00A0{s1}\u00A0{s2}",
                "—á—Ç–æ\u00A0–∑–∞\u00A0{s2}\u00A0—Ç–∞–∫–æ–π?",
                "{s1},\u00A0{s3}\u00A0–∏\u00A0–µ—â–µ\u00A0—Ä–∞–∑\u00A0{s2}!",
                "—Ç–∏–ø–∞\u00A0{s1}",
                "–∞\u00A0–≤–æ—Ç\u00A0{s2}",
                "–ø—Ä–æ—Å—Ç–æ\u00A0{s1}\u00A0–∏\u00A0{s3}",
                "–æ—Ö—É–µ—Ç—å,\u00A0{s2}!"*/
            ];

            function applyOrthographicRule(baseStr, nextPart) {
                if (!baseStr || !nextPart) return baseStr;
                const lastCharBase = baseStr.slice(-1);
                const firstCharNext = nextPart[0];
                const consonants = ['–¥', '–≤', '—Ç', '–±']; // Cyrillic
                const vowels = ['–π', '–µ']; // Cyrillic

                if (consonants.includes(lastCharBase) && vowels.includes(firstCharNext)) {
                    return baseStr + '–™'; // Cyrillic Hard Sign
                }
                return baseStr;
            }


            function generateSinglePart(gender, usePronoun) {
                const { rw, rd } = generateWordIndices();
                let part = words[rw] + prefixes[getRandomInt(MaxPrefixes)];
                let temp;
                if (usePronoun) {
                    // Ensure pronouns[gender] exists and has elements
                    if (pronouns[gender] && pronouns[gender].length > 0) {
                         temp = dermo[rd] + pronouns[gender][getRandomInt(pronouns[gender].length)];
                    } else {
                        // Fallback or error handling if pronouns for a gender are missing
                        console.warn(`Pronouns not defined for gender ${gender}`);
                        temp = dermo[rd]; // Or some default
                    }
                } else {
                    // Ensure suffixes[gender] exists and has elements
                    if (suffixes[gender] && suffixes[gender].length > 0) {
                        temp = dermo[rd] + suffixes[gender][getRandomInt(suffixes[gender].length)];
                    } else {
                        // Fallback or error handling
                        console.warn(`Suffixes not defined for gender ${gender}`);
                        temp = dermo[rd]; // Or some default
                    }
                }
                part = applyOrthographicRule(part, temp);
                part += temp;
                return part;
            }

            function generateAndDisplayPhrase() {
                const gender = getRandomInt(3); // 0, 1, or 2

                // Generate all potential parts. Templates will pick what they need.
                // This ensures the stack-based anti-repetition works as before
                // for up to 3 "slots" of word/dermo combinations.
                const s1_raw = generateSinglePart(gender, true);  // pronoun-based
                const s2_raw = generateSinglePart(gender, false); // suffix-based
                const s3_raw = generateSinglePart(gender, true);  // pronoun-based, different from s1 due to stack

                const selectedTemplate = phraseTemplates[getRandomInt(phraseTemplates.length)];

                // Populate the template
                // Using global replace (g flag) in case a template might reuse a placeholder (though current ones don't)
                currentPhraseRaw = selectedTemplate
                    .replace(/{s1}/g, s1_raw)
                    .replace(/{s2}/g, s2_raw)
                    .replace(/{s3}/g, s3_raw);
                // If a template is "—Ö—É–π", placeholders won't be found, which is fine.

                currentPhraseReadable = readable(currentPhraseRaw);
                phraseOutputSpan.textContent = currentPhraseReadable;

                if (speechEnabled && currentPhraseReadable) {
                    speakText(currentPhraseReadable); // Always speak the readable (potentially edited) version
                }
            }

            function populateVoiceList() {
                const voices = window.speechSynthesis.getVoices();
                voiceSelect.innerHTML = ''; // Clear existing options

                const russianVoices = voices.filter(voice => voice.lang.startsWith('ru'));

                if (russianVoices.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = voices.length === 0 ? '–ó–∞–≥—Ä—É–∑–∫–∞ –≥–æ–ª–æ—Å–æ–≤...' : '–†—É—Å—Å–∫–∏–µ –≥–æ–ª–æ—Å–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã';
                    option.disabled = true;
                    voiceSelect.appendChild(option);
                    voiceSelect.disabled = true;
                    selectedVoice = null;
                    if (voices.length > 0) {
                        console.warn('No Russian voices found. Other voices available:', voices.length);
                    }
                    return;
                }

                voiceSelect.disabled = false;
                let firstRussianVoice = null;

                russianVoices.forEach((voice) => {
                    const option = document.createElement('option');
                    option.textContent = `${voice.name} (${voice.lang})`;
                    option.value = voice.voiceURI; // Use voiceURI as value
                    voiceSelect.appendChild(option);

                    // Keep track of the first Russian voice to select it by default
                    if (!firstRussianVoice) {
                        firstRussianVoice = voice;
                    }
                });

                // Select the first Russian voice in the dropdown and store the object
                if (firstRussianVoice) {
                    voiceSelect.value = firstRussianVoice.voiceURI;
                    selectedVoice = firstRussianVoice;
                } else {
                    // This case should ideally not be reached if russianVoices.length > 0
                    // but as a fallback, if somehow no voice got selected.
                    selectedVoice = null;
                    console.warn('Could not select a default Russian voice.');
                }
            }

            function speakText(text) {
                if ('speechSynthesis' in window) {
                    if (!selectedVoice || !text) {
                         if (!selectedVoice) console.warn('No voice selected for speech.');
                         if (!text) console.warn('No text to speak.');
                         return;
                    }

                    // Cancel any ongoing speech before starting a new one
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);

                    // Use the selected voice
                    utterance.voice = selectedVoice;
                    // utterance.lang = selectedVoice.lang; // Setting lang explicitly might interfere with voice's own lang

                    window.speechSynthesis.speak(utterance);
                } else {
                    console.warn('Web Speech API not supported in this browser.');
                }
            }

            // --- Event Listeners ---
            generateButton.addEventListener('click', generateAndDisplayPhrase);
            function toggleSpeech() {
                speechEnabled = !speechEnabled;
                toggleSpeechButton.textContent = `–†–µ—á—å: ${speechEnabled ? '–í–∫–ª' : '–í—ã–∫–ª'}`;
                if (speechEnabled) {
                    toggleSpeechButton.style.backgroundColor = '#61afef'; // Blue
                } else {
                    toggleSpeechButton.style.backgroundColor = '#c678dd'; // Purple for off, or another distinct color
                    if ('speechSynthesis' in window) {
                        window.speechSynthesis.cancel(); // Stop any ongoing speech if disabled
                    }
                }
            }

            function repeatCurrentSpeech() {
                if (speechEnabled) {
                    const textToSpeak = phraseOutputSpan.textContent; // Speak current content of the editable span
                    if (textToSpeak) { // Ensure textToSpeak is not empty
                        speakText(textToSpeak);
                    }
                }
            }

            function copyToClipboard() {
                const textToCopy = phraseOutputSpan.textContent; // Copy the current visible (and possibly edited) text
                if (!textToCopy) {
                    return;
                }
                navigator.clipboard.writeText(textToCopy).then(() => {
                    console.log('Phrase copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy phrase: ', err);
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ñ—Ä–∞–∑—É. –í–∞—à –±—Ä–∞—É–∑–µ—Ä –º–æ–∂–µ—Ç –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –∏–ª–∏ —Ç—Ä–µ–±–æ–≤–∞—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ (HTTPS).');
                });
            }

            toggleSpeechButton.addEventListener('click', toggleSpeech);
            // toggleSpeechSourceButton.addEventListener('click', toggleSpeechSource); // Removed
            repeatSpeechIconButton.addEventListener('click', repeatCurrentSpeech); // New listener for icon
            copyToClipboardButton.addEventListener('click', copyToClipboard); // New listener for icon
            // saveButton.addEventListener('click', savePhraseToFile); // Removed

            // Event listener for voice selection change
            voiceSelect.addEventListener('change', () => {
                const selectedVoiceURI = voiceSelect.value;
                const voices = window.speechSynthesis.getVoices();
                selectedVoice = voices.find(voice => voice.voiceURI === selectedVoiceURI);
                // console.log("Voice changed to:", selectedVoice ? selectedVoice.name : 'None');
            });

            phraseOutputSpan.addEventListener('input', () => {
                currentPhraseReadable = phraseOutputSpan.textContent;
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (event) => {
                 if (event.target === phraseOutputSpan) {
                     return; // Don't trigger shortcuts if typing in the editable span
                 }

                 const key = event.key.toUpperCase();
                 if (key === 'T') { // Toggle speech
                    event.preventDefault(); // Prevent default 't' behavior if any
                    toggleSpeech();
                } else if (event.key === 'Escape') {
                    // No specific action for Escape in this version
                } else {
                         // Any other single key press triggers generation, unless it's a modifier key
                         if (!event.metaKey && !event.ctrlKey && !event.altKey && event.key.length === 1) {
                              generateAndDisplayPhrase();
                         }
                    
                }
            });

            // Initial setup
            // Initialize currentPhraseReadable with the placeholder text
            currentPhraseReadable = phraseOutputSpan.textContent;

            toggleSpeechButton.textContent = `–†–µ—á—å: ${speechEnabled ? '–í–∫–ª' : '–í—ã–∫–ª'}`;
            if (speechEnabled) {
                toggleSpeechButton.style.backgroundColor = '#61afef';
            } else {
                toggleSpeechButton.style.backgroundColor = '#c678dd';
            }
            // Initial setup for speech source button removed
            
            // Initial voice list population and setup
            populateVoiceList();
            if ('speechSynthesis' in window) {
                window.speechSynthesis.onvoiceschanged = populateVoiceList;
            } else {
                console.warn('Web Speech API not supported.');
                voiceSelect.disabled = true;
                const option = document.createElement('option');
                option.textContent = 'API —Ä–µ—á–∏ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è';
                option.disabled = true;
                voiceSelect.appendChild(option);
            }
            // Initial phrase generation on load? (Optional)
            // generateAndDisplayPhrase(); 
        });
    </script>
</body>
</html>
<!-- This is the end of the HTML file. -->