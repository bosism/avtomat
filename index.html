<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVTOMAT - –í–µ–±-–≤–µ—Ä—Å–∏—è</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #282c34; /* Dark background */
            color: #abb2bf; /* Light grey text */
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            flex-direction: column; /* Allow stacking of container and qwen output */
            box-sizing: border-box;
        }

        .container {
            background-color: #353a43; /* Slightly lighter dark for container */
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-align: center;
            max-width: 700px;
            width: 90%;
            margin-bottom: 20px; /* Space before Qwen output */
        }

        header h1 {
            color: #61afef; /* Blue accent */
            font-family: "Courier New", Courier, monospace; /* Monospaced for title */
        }

        #ascii-art-rifle {
            font-family: "Consolas", "Courier New", Courier, monospace;
            letter-spacing: 0;
            white-space: pre;
            background-color: #21252b; /* Darker background for pre */
            color: #98c379; /* Green accent for "code" */
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
            text-align: left;
            border: 1px solid #4b5263;
            margin-bottom: 20px; /* Added margin */
            line-height: 1.2; /* Adjust line height for better art display */
        }

        .controls button {
            margin: 8px;
            padding: 12px 18px;
            border: none;
            border-radius: 5px;
            background-color: #61afef; /* Blue accent */
            color: #282c34; /* Dark text on button */
            cursor: pointer;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out;
        }

        .controls button:hover {
            background-color: #5295cc; /* Darker blue on hover */
        }

        .output-area {
            margin-top: 25px;
            padding: 20px;
            background-color: #21252b; /* Darker background for output */
            border-radius: 5px;
            min-height: 60px;
            font-size: 1.3em;
            /* color: #e5c07b; */ /* Moved to #phraseOutputSpan */
            border: 1px solid #4b5263;
            word-wrap: break-word;
            text-align: left; /* For better editing experience */
            display: flex; /* To align text and icons nicely */
            align-items: center; /* Vertically align text and icons */
        }
        #phraseOutputSpan {
            flex-grow: 1; /* Allow text span to take available space */
            color: #e5c07b; /* Yellow/Orange accent for output text */
            outline: none; /* Remove default outline, we'll add a custom focus style */
        }
        .output-actions {
            flex-shrink: 0; /* Prevent icons from shrinking */
            margin-left: 10px; /* Space between text and icons */
        }

        .icon-button {
            background: none;
            border: none;
            color: #abb2bf; /* Light grey text, same as body */
            cursor: pointer;
            font-size: 1.2em; /* Adjust icon size */
            padding: 5px;
            margin-left: 5px; /* Space between icons */
            transition: color 0.2s ease-in-out;
        }

        .icon-button:hover {
            color: #61afef; /* Blue accent on hover */
        }

        #phraseOutputSpan[contenteditable="true"]:focus {
            outline: 1px solid #61afef !important; /* Blue accent for focus, !important to override browser defaults if any */
            background-color: #2c313a; /* Slightly lighter background when editing */
            box-shadow: 0 0 3px rgba(97, 175, 239, 0.3); /* Optional: add a glow */
        }

        footer {
            margin-top: 25px;
            font-size: 0.9em;
            color: #7f848e;
        }

        .qwen-output-container {
            background-color: #353a43;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            max-width: 700px;
            width: 90%;
            text-align: left; /* Align heading to left */
        }
        .qwen-output-container h3 {
            color: #61afef;
            font-family: "Courier New", Courier, monospace;
            margin-top: 0; /* Remove default top margin for h3 */
        }
        #qwenOutput {
            background-color: #21252b;
            color: #abb2bf;
            padding: 15px;
            border-radius: 5px;
            min-height: 100px;
            white-space: pre-wrap; /* Important for wrapping long lines */
            word-wrap: break-word; /* Break long words */
            border: 1px solid #4b5263;
            font-family: "Consolas", "Courier New", Courier, monospace; /* Consistent monospaced font */
            font-size: 1em; /* Adjust as needed */
            line-height: 1.4; /* Better readability for prose */
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>AVTOMAT</h1>
            <pre id="ascii-art-rifle">
                     ________________
                    //~~~~~~~~~~~~~~\\                  /‚îê
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ_____[=~~~~~~~~~~~~~~~~~~‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚î¨‚îê   /__‚îÇ
‚îÇ~~                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ=======####
‚îÇ   ~~~_=====~~~~~‚îÄ‚î¨   ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îêo      ‚îå‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚î¥‚îò      '
‚îÇ   _-~            ‚îÇ   ‚îÇ_____‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
 ~~~               ‚îÇ   ‚îÇ     ‚îÇ||  |  ‚îÇ AvtoMat Profesional 1.0
                   ‚îÇ   ‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                   ‚îî‚îÄ‚îÄ‚îÄ‚î¥

            </pre>
        </header>

        <div class="controls">
            <button id="generateButton">–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å (–ª—é–±–∞—è –∫–ª–∞–≤–∏—à–∞)</button>
            <button id="toggleSpeechButton">–†–µ—á—å: –í–∫–ª</button>
            <!-- <button id="toggleSpeechSourceButton">–ò—Å—Ç–æ—á–Ω–∏–∫ —Ä–µ—á–∏: Raw</button> Removed -->
            <!-- <button id="saveButton">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ñ—Ä–∞–∑—É</button> Removed -->
        </div>

        <div class="output-area">
            <span id="phraseOutputSpan" contenteditable="true">–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏–ª–∏ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É –¥–ª—è –Ω–∞—á–∞–ª–∞...</span>
            <span class="output-actions">
                <button id="repeatSpeechIconButton" class="icon-button" title="–ü–æ–≤—Ç–æ—Ä–∏—Ç—å —Ä–µ—á—å">üîä</button> <!-- Speaker Icon -->
                <button id="copyToClipboardButton" class="icon-button" title="–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å">üìã</button> <!-- Clipboard Icon -->
            </span>
        </div>

        <footer>
            <p>–ù–∞–∂–º–∏—Ç–µ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏. 'T' - –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å —Ä–µ—á—å.</p>
        </footer>
    </div>

    <div class="qwen-output-container">
        <h3>–°–æ—á–∏–Ω–µ–Ω–∏–µ –æ—Ç Qwen:</h3>
        <pre id="qwenOutput">–ó–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è —Å–æ—á–∏–Ω–µ–Ω–∏–µ...</pre>
    </div>

    <script>
        // --- Qwen API Call Function (Streaming) ---
        async function callQwen(promptForQwen) {
            const qwenResponseBox = document.getElementById('qwenOutput');
            if (!qwenResponseBox) {
                console.error("Qwen output element not found!");
                return;
            }
            qwenResponseBox.textContent = "–ó–∞–ø—Ä–∞—à–∏–≤–∞—é —Å–æ—á–∏–Ω–µ–Ω–∏–µ —É Qwen..."; // Initial message

            // IMPORTANT: Replace with YOUR OpenRouter API Key
            const apiKey = "YOUR_OPENROUTER_API_KEY"; // Replace with your actual OpenRouter API key
            
            const siteUrl = window.location.hostname ? `${window.location.protocol}//${window.location.hostname}${window.location.port ? ':' + window.location.port : ''}` : "https://avtomat.example.com"; // Fallback for file:// or provide your site
            const siteTitle = "AVTOMAT with Qwen"; // Your site title

            try {
                const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${apiKey}`,
                        "Content-Type": "application/json",
                        "HTTP-Referer": siteUrl,
                        "X-Title": siteTitle
                    },
                    body: JSON.stringify({
                        model: "deepseek/deepseek-r1-zero:free", // Or your preferred Qwen model
                        messages: [
                            { role: "user", content: promptForQwen }
                        ],
                        stream: true 
                    })
                });

                if (!res.ok) {
                    let errorBody = '';
                    try {
                        errorBody = await res.text();
                    } catch (e) { /* ignore */ }
                    throw new Error(`HTTP ${res.status} - ${res.statusText}. Response: ${errorBody}`);
                }

                qwenResponseBox.textContent = ""; // Clear "–ó–∞–ø—Ä–∞—à–∏–≤–∞—é..."
                const reader = res.body.getReader();
                const decoder = new TextDecoder("utf-8");
                let buffer = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        if (qwenResponseBox.textContent.trim() === "") {
                            qwenResponseBox.textContent = "–ü–æ—Ç–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω, –Ω–æ Qwen –Ω–∏—á–µ–≥–æ –Ω–µ –æ—Ç–≤–µ—Ç–∏–ª.";
                        }
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;

                    let boundary = buffer.indexOf("\n\n");
                    while (boundary !== -1) {
                        const eventDataString = buffer.substring(0, boundary);
                        buffer = buffer.substring(boundary + 2); 

                        if (eventDataString.startsWith("data: ")) {
                            const jsonData = eventDataString.substring(6).trim(); 
                            if (jsonData === "[DONE]") {
                                if (qwenResponseBox.textContent.trim() === "" && !reader.closed) {
                                    qwenResponseBox.textContent = "–ü–æ—Ç–æ–∫ –∑–∞–≤–µ—Ä—à–µ–Ω –º–∞—Ä–∫–µ—Ä–æ–º [DONE], –Ω–æ —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ –æ—Ç–≤–µ—Ç–∞ –Ω–µ –±—ã–ª–æ.";
                                }
                                await reader.cancel(); 
                                return; 
                            }
                            try {
                                const parsedData = JSON.parse(jsonData);
                                const contentDelta = parsedData.choices?.[0]?.delta?.content;
                                if (contentDelta) {
                                    qwenResponseBox.textContent += contentDelta;
                                }
                            } catch (e) {
                                console.error("–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON –∏–∑ –ø–æ—Ç–æ–∫–∞ Qwen:", e, "–î–∞–Ω–Ω—ã–µ:", jsonData);
                            }
                        }
                        boundary = buffer.indexOf("\n\n");
                    }
                }
            } catch (error) {
                console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ Qwen (streaming):", error);
                qwenResponseBox.textContent = "–û—à–∏–±–∫–∞ –æ—Ç Qwen: " + error.message;
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            // --- Data from Pascal program ---
            const MaxWords = 12;
            const MaxPrefixes = 11;
            const MaxDermo = 21;
            const MaxSuffixes = 2; // Per gender
            const MaxPronouns = 1; // Per gender
            const StackSize = 5;

            const words = ['—Ö—É–µ', '–ø–∏–∑–¥–æ', '–¥–µ—Ä—å–º–æ', '–∂–æ–ø–æ', '—á–ª–µ–Ω–æ', '–ø–∞—Ä–∞—à–µ', '–≥–∞–Ω–¥–æ–Ω–æ', '–º—É–¥–æ', '—Å—É–∫–æ', '–≤–∞—Ñ–ª–µ', '–∑–∞–ª—É–ø–æ', '–ø–æ–Ω–æ—Å–æ'];
            const prefixes = ['–∑–∞', '–≤—ã', '–ø—Ä–æ', '—Ä–∞–∑', '–Ω–∞–¥', '–ø–æ–¥', '–ø–µ—Ä–µ', '–Ω–µ–¥–æ', '–æ–±', '–≤', '–æ—Ç'];
            const dermo = ["–π–æ'–±—ã–≤", "–¥—Ä–∏'—Å—Ç—ã–≤", "—Å–∞'—Å—ã–≤", '—Å–µ—Ä', "–¥—Ä–∞'—á–∏–≤", "–∂—É'–∂–∂–∏–≤", '–µ–¥', '–∂–∏—Ä', "–≥–ª–∞'—Ç—ã–≤", '—Ä—ã–≤', "—Ö—É—è'—Ä–∏–≤", "–ª–∏'–∑—ã–≤", '–¥–µ—Ä', "–ª–∞'–º—ã–≤", '–±–∏–≤', '—Ä–µ–∑', "–ø–∏'–∑–∂–∏–≤", "—Ö–≤–∞'—Ç—ã–≤", "–∫—É'—Å—ã–≤", "–ø–∏–∑–¥—Ä—é'—á–∏–≤", '–∂–∏–º'];

            // JS arrays are 0-indexed, Pascal arrays were 1-indexed for suffixes/pronouns inner arrays
            // Gender: 0 (masc), 1 (fem), 2 (neuter)
            const suffixes = [
                ["–∞'–ª—å—â–∏–∫", "–∞'—Ç–µ–ª—å"],    // Gender 0
                ["–∞'–ª–∫–∞", "–∞'–ª—å—â–∏—Ü–∞"],  // Gender 1
                ["–∞'–ª–∏—â–µ", "–∞'–ª–æ"]       // Gender 2
            ];
            const pronouns = [
                ["–∞'—é—â–∏–π"],             // Gender 0
                ["–∞'—é—â—è—è"],             // Gender 1
                ["–∞'—é—â–µ–µ"]              // Gender 2
            ];

            // --- Global state ---
            let currentPhraseRaw = '';
            let currentPhraseReadable = '';
            let speechEnabled = true; // Speech is on by default
            let stack1 = []; // For words indices
            let stack2 = []; // For dermo indices

            // --- UI Elements ---
            const generateButton = document.getElementById('generateButton');
            const toggleSpeechButton = document.getElementById('toggleSpeechButton');
            // const toggleSpeechSourceButton = document.getElementById('toggleSpeechSourceButton'); // Removed
            const phraseOutputSpan = document.getElementById('phraseOutputSpan');
            const repeatSpeechIconButton = document.getElementById('repeatSpeechIconButton');
            const copyToClipboardButton = document.getElementById('copyToClipboardButton');
            const qwenOutputElem = document.getElementById('qwenOutput'); // Reference for Qwen output

            // --- Helper Functions ---
            function getRandomInt(max) { // Returns 0 to max-1
                return Math.floor(Math.random() * max);
            }

            function readable(s) {
                let str = '';
                for (let i = 0; i < s.length; i++) {
                    if (s[i] === '–π' && s[i + 1] === '–æ' && i < s.length - 1) {
                        str += '—ë'; // Cyrillic '—ë' (yo) - was '–µ' before, '—ë' is more accurate for "–π–æ"
                        i++;
                    } else if (s[i] !== "'") { // Changed from '+' to "'"
                        str += s[i];
                    }
                }
                return str;
            }

            function addToStack(stack, item) {
                if (stack.length >= StackSize) {
                    stack.shift(); // Remove oldest
                }
                stack.push(item);
            }

            function isInStack(stack, item) {
                return stack.includes(item);
            }

            function generateWordIndices() {
                let rw, rd;
                do {
                    rw = getRandomInt(MaxWords); // 0-indexed
                } while (isInStack(stack1, rw));
                addToStack(stack1, rw);

                do {
                    rd = getRandomInt(MaxDermo); // 0-indexed
                } while (isInStack(stack2, rd));
                addToStack(stack2, rd);
                return { rw, rd };
            }

            function applyOrthographicRule(baseStr, nextPart) {
                if (!baseStr || !nextPart) return baseStr;
                const lastCharBase = baseStr.slice(-1);
                const firstCharNext = nextPart[0];
                const consonants = ['–¥', '–≤', '—Ç', '–±']; // Cyrillic
                const vowels = ['–π', '–µ']; // Cyrillic

                if (consonants.includes(lastCharBase) && vowels.includes(firstCharNext)) {
                    return baseStr + '–™'; // Cyrillic Hard Sign
                }
                return baseStr;
            }


            function generateSinglePart(gender, usePronoun) {
                const { rw, rd } = generateWordIndices();
                let part = words[rw] + prefixes[getRandomInt(MaxPrefixes)];
                let temp;
                if (usePronoun) {
                    // Ensure pronouns[gender] exists and has elements
                    if (pronouns[gender] && pronouns[gender].length > 0) {
                         temp = dermo[rd] + pronouns[gender][getRandomInt(pronouns[gender].length)];
                    } else {
                        // Fallback or error handling if pronouns for a gender are missing
                        console.warn(`Pronouns not defined for gender ${gender}`);
                        temp = dermo[rd]; // Or some default
                    }
                } else {
                    // Ensure suffixes[gender] exists and has elements
                    if (suffixes[gender] && suffixes[gender].length > 0) {
                        temp = dermo[rd] + suffixes[gender][getRandomInt(suffixes[gender].length)];
                    } else {
                        // Fallback or error handling
                        console.warn(`Suffixes not defined for gender ${gender}`);
                        temp = dermo[rd]; // Or some default
                    }
                }
                part = applyOrthographicRule(part, temp);
                part += temp;
                return part;
            }

            function generateAndDisplayPhrase() {
                const gender = getRandomInt(3); // 0, 1, or 2

                const s1_raw = generateSinglePart(gender, true); // true for pronoun
                const s3_raw = generateSinglePart(gender, true); // true for pronoun
                const s2_raw = generateSinglePart(gender, false); // false for suffix

                // Combine parts
                const choice = getRandomInt(4);
                switch (choice) {
                    case 0:
                        currentPhraseRaw = s1_raw + "\u00A0" + s2_raw; // \u00A0 is non-breaking space
                        break;
                    case 1:
                        currentPhraseRaw = s1_raw + "\u00A0" + s3_raw + " " + s2_raw;
                        break;
                    case 2:
                        currentPhraseRaw = s2_raw;
                        break;
                    case 3:
                        currentPhraseRaw = "—Ö—É–π"; // Changed from '+' to "'"
                        break;
                }

                currentPhraseReadable = readable(currentPhraseRaw);
                phraseOutputSpan.textContent = currentPhraseReadable;

                if (speechEnabled && currentPhraseReadable) {
                    speakText(currentPhraseReadable);
                }

                // --- MODIFIED: Call Qwen with the generated phrase ---
                if (currentPhraseReadable && currentPhraseReadable.trim() !== "" && currentPhraseReadable !== "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏–ª–∏ –ª—é–±—É—é –∫–ª–∞–≤–∏—à—É –¥–ª—è –Ω–∞—á–∞–ª–∞...") {
                    // const qwenPrompt = `–Ω–∞—Ä–∏—à–∏ —Å–æ—á–∏–Ω–µ–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑—É—è —ç—Ç—É —Ñ—Ä–∞–∑—É: ${currentPhraseReadable}`; // Original user request
                    const qwenPrompt = `–Ω–∞–ø–∏—à–∏ —Å–æ—á–∏–Ω–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É—è —ç—Ç—É —Ñ—Ä–∞–∑—É: ${currentPhraseReadable}`; // "–Ω–∞–ø–∏—à–∏" is more standard for essay
                    callQwen(qwenPrompt);
                } else {
                    if (qwenOutputElem) {
                        qwenOutputElem.textContent = "–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —Ñ—Ä–∞–∑—É, —á—Ç–æ–±—ã Qwen –º–æ–≥ –Ω–∞–ø–∏—Å–∞—Ç—å —Å–æ—á–∏–Ω–µ–Ω–∏–µ.";
                    }
                }
            }

            function speakText(text) {
                if ('speechSynthesis' in window) {
                    // Cancel any ongoing speech before starting a new one
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.lang = 'ru-RU'; // Set language to Russian
                    
                    // Attempt to find a Russian voice
                    const voices = window.speechSynthesis.getVoices();
                    const russianVoice = voices.find(voice => voice.lang === 'ru-RU');
                    if (russianVoice) {
                        utterance.voice = russianVoice;
                    } else {
                        console.warn('Russian voice not found, using default.');
                    }
                    
                    window.speechSynthesis.speak(utterance);
                } else {
                    console.warn('Web Speech API not supported in this browser.');
                }
            }
            
            // Pre-load voices for better voice selection (optional but good practice)
            if ('speechSynthesis' in window && window.speechSynthesis.getVoices().length === 0) {
                 window.speechSynthesis.onvoiceschanged = () => {
                    // This event might fire multiple times.
                    // You could call speakText here if you need to ensure voices are loaded before first speech.
                    // For now, just logging.
                    // console.log("Voices loaded:", window.speechSynthesis.getVoices());
                };
            }


            function toggleSpeech() {
                speechEnabled = !speechEnabled;
                toggleSpeechButton.textContent = `–†–µ—á—å: ${speechEnabled ? '–í–∫–ª' : '–í—ã–∫–ª'}`;
                toggleSpeechButton.style.backgroundColor = speechEnabled ? '#61afef' : '#c678dd';
                if (!speechEnabled && 'speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                }
            }

            function repeatCurrentSpeech() {
                if (speechEnabled) {
                    const textToSpeak = phraseOutputSpan.textContent; // Speak current content of the editable span
                    if (textToSpeak) { // Ensure textToSpeak is not empty
                        speakText(textToSpeak);
                    }
                }
            }

            function copyToClipboard() {
                const textToCopy = phraseOutputSpan.textContent; // Copy the current visible (and possibly edited) text
                if (!textToCopy) {
                    return;
                }
                navigator.clipboard.writeText(textToCopy).then(() => {
                    console.log('Phrase copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy phrase: ', err);
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ñ—Ä–∞–∑—É.');
                });
            }

            // --- Event Listeners ---
            generateButton.addEventListener('click', generateAndDisplayPhrase);
            toggleSpeechButton.addEventListener('click', toggleSpeech);
            repeatSpeechIconButton.addEventListener('click', repeatCurrentSpeech);
            copyToClipboardButton.addEventListener('click', copyToClipboard);

            // This event listener updates the readable phrase if user edits.
            // Qwen is only called on new generation, not on edit.
            phraseOutputSpan.addEventListener('input', () => {
                // currentPhraseReadable = phraseOutputSpan.textContent; // This updates the variable if needed elsewhere
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (event) => {
                if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                    return;
                }

                const key = event.key.toUpperCase();
                if (key === 'T') {
                    event.preventDefault(); // Prevent default 't' behavior if any
                    toggleSpeech();
                } else {
                     // Generate on any other key (if not T and not a modifier/special key)
                    if (!event.metaKey && !event.ctrlKey && !event.altKey && event.key.length === 1 && key !== 'T') {
                         generateAndDisplayPhrase();
                    }
                }
            });

            toggleSpeechButton.textContent = `–†–µ—á—å: ${speechEnabled ? '–í–∫–ª' : '–í—ã–∫–ª'}`;
            toggleSpeechButton.style.backgroundColor = speechEnabled ? '#61afef' : '#c678dd';
            if (qwenOutputElem) {
                 qwenOutputElem.textContent = "–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ —Ñ—Ä–∞–∑—É, —á—Ç–æ–±—ã Qwen –º–æ–≥ –Ω–∞–ø–∏—Å–∞—Ç—å —Å–æ—á–∏–Ω–µ–Ω–∏–µ.";
            }
        });
    </script>
</body>
</html>
